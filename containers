1) Containers Machanisms
------------------------

cgroups: manage resources for groups of processes.

namespaces: per-process resource isolation.

seccomp: constraints syscalls.

capabilities: privileges avaiable to processes.

2) Cgroups
----------

In sysfs there is a mount point to a new filesystem type, cgroup: /sys/fs/cgroup

Subfolders that describe what can be done with the resource of the folder,
for example there are the cpu and mem folders.

In each task_struct there is a pointer to a css_set group and task_struct are
also linked list items for each cgroup.

task_struct {                   css_set {
  css_set* cgroups    <------->   list_head tasks
  list_head cg_list               cgroup_subsys_state * subsys[]
}                               }

cgroup_subsys {
  int (*attach)(...)
  void (*fork)(...)
  void (*exit)(...)
  void (*bind)(...)
  
  const char* name
  cgroupsfs_root *root
  cftype *base_cftypes
}

Several functions pointers to monitor syscalls for each cgroups.
In base_cftypes describe the resources (files) allowed to access to the cgroup.

3) Namespaces
-------------

Different view of data structures and names at process granularity.

 - mnt
 - pid
 - net
 - ipc
 - uts (unix timesharing, different hostnames)
 - user

New namespaces created with clone() (new proccess) or unshare() (current).
setns() attach a process to an existing namespace.

Each namespace is identified by an unique inode in /proc/<pid>/ns.

task_struct {
  struct nsproxy *nsproxy
  struct cred* cred
}

nsproxy is shared between all task_structs with the same set of namespaces.

nsproxy {
  atomic_t count
  struct uts_namespace* uts_ns
  struct ipc_namespace* ipc_ns
  struct mnt_namespace* mnt_ns
  struct pid_namespace* pid_ns_for_children
  struct net* net_ns
}

struct cred {
  user_ns
}

A new net namespace only include lo device. A network device belongs only to a
namespace. A virtual device should be created and communicate with real device
using network stack.

struct pid links togheter pids in a namespace.





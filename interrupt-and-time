1) Realtime OS
--------------

Soft real-time and hard-realtime.
Hard realtime must have a very low error on time. For instance a car have a
real time OS.

Linux is not considered a real-time OS.

2) IDT and GDT
--------------

In Interrupt Descriptor Table we map a selector to an offset.
The selector pick a segment descriptor in GDT. Adding offset to the base of
this segment descripor points to the interrupt handler.
IDTR and GDTR are per-CPU registers.

On IDT entries, the type classify the trap associated.

Look at the idt_bits and gate_struct on Linux. On the entry there is specified
also the DPL and the Interrupt Stack Table (IST).

When receiving interrupts in user mode we want to transition to kernel space.
Use gate to set priviledge.

3) IDT Entry Initialization
---------------------------

pack_gate() takes parameters for you and fills the gate entry.

Parameters are: gate_desc*, type, func, dpl, ist, seg.

Executing pack_gate directly on IDT entry will cause a crash.
This function execute many instructions, so the way is:

 - Clone IDT entry
 - Operate on the clone
 - Store the clone on the IDT entry (one onstruction, not many)

4) Entries types
----------------

256 possible entries. Each entry is common called vector.

 - 0-19 not maskable interrupts and exceptions (even with IF=0)
 - 20-31 reserved
 - 32-127 IRQs
 - 128 syscalls
 - 129-238 IRQs
 - 239 local APIC timer interrupt
 - 240-250 reserved for future
 - 251-255 interprocessor interrupts

 Each LAPIC is a interrupt dipatcher and has is time.

5) Gate descriptor
------------------

It is basically a segment descriptor with 4 types:

 - call-gate:
      Register a func ptr that is a cross ring call specifying the number of
      arguments (those arguments are pushed on src ring stack and the firmware
      copy them to the new stack). There is not an OS using it.
 
 - interrupt-gate
 - trap-gate
 
 - task-gate:
      Made to jump to the scheduler. With NT (Next Task) flag a task can yield
      explicetely the cpu to a different task. This lives on TSS an no one is
      using this.

6) Interrupts VS Traps
----------------------

Async events are interrupts. Can be generated by devices and some of them can be
masked or not (NMI).

Trap (or exceptions) are synchronous strictly related to the CPU exection.

Using interrupt gates you are telling the firmware to clear the interrupt
flag (IF). With a trap gate this is not done.

7) Global activation scheme
---------------------------

When receveing a trap a very simple stub is activated. It pushes on the stack
a code used by the dispatcher to know where to jump (error code).
Then jump to the handler second stub.

Interrupt goes directly to handler (vector num pushed by firmware).

x86 interrupt framei (RSP):
  - error code/vector
  - RIP
  - CS
  - FLAGS
  - SP
  - SS

The handler makes uniform this frame (align stack in case of IRQ etc.)

Then the dispatcher is called. It firstly change GS to the value needs in
kernel space if the interrupt comes from user space (pre CPU vars).

Push the content of the context on pt_regs.

Then activate the proper handler.

The handler returns to the dispatcher that do cleanup and calls iret.

swapgs instruction swap GS if coming from userpace. It relies on another MSR.
The other incarnation of GS is GSMSR and swapgs exchange those two regs.

User space provenience can be seen using the CPL in the CS on stack.

Calls into do_page_fault.

8) Do page fault
----------------

Store in CR2 the address that generates the fault.

Fault type in error code. The instruction address that generated the fault can
be easily taken from RSP (pushed RIP).

In copy_from_user if passed a wrong address the kernel generates a page fault.
Otherwise access checking would be costly.

The pieces of the kernel that are allowed to crash uses code in a special
section .fixup to recover (e.g. in copy_from_user readed bytes are set to 0).

Pieces in .fixup rejumps to .text.

__ex_table is a section used to map text and fixup addresses.

In 64 bits this changed.

To maintain 32 bit in fixup table offset to current location are used.

9) Multi Core
-------------

On a single core the hardware is time shared across threads and this ensure
consistency of interrupts/traps.

On multi-core, interrupts are delivered to a single core but other core may run
another thread of the same application.

This may lead to race conditions.

Also sync code in userspace like VDSO is affected.

Memory unmapping is an example, a portion of the address space if teared down.
The kernel code has to flush a part of TLB also. The thread that called munmap
see a consistent state thanks to the TLB update and this is also true for all
the other threads on the same core.

But if a thread of the same process is on another core? The hardware state is
inconsistent! The unammped page is still cached on TLB of such core.

10) Inter Processor Interrupts
------------------------------

Generated by software. They are synchronous from a core to another.
With this mechanism a core can trigger a state change in another core.
There are at least 2 priority levels, high or low.
Low priority are generally enqueued and then sended in batch.

IPI are an interface to APIC/LAPIC circuitry.
IPI requests go along a dedicated APIC bus (QuickPath on modern Intels).

In Linux high priority are used in critical situation like for sending halt
after a panic on a core.

There are only 4 avaiable vectors.0
A dedicated vector is for flushing the TLB only (0xfd).
Via CALL_FUNCTION_VECTOR is general purpose that calls a function pointer
on the another core.

11) IPI API
-----------

Defined in struct ipi.

There is a way to register an IPI function (this is needed cause there is
only CALL_FUNCTION_VECTOR).

In old kernel there was a global struct under locks.
In 5.0 there is a pre-CPU lock-free linked list.

Old steps are:

  - Lock
  - Set global function pointer
  - Set a global pointer as argument to the function
  - Send IPI
  - Other core copies function pointer and arg pointer to local variables
  - Other core unlock

This does not scale. The lock-free is a better solution:

A CPU adds an element (function + argument) to all the per-CPU lists of the
other cores (yes, a bit spooky) and the trigger the IPI.

(Remeber lock-free lists use CAS for insertion, see data-structs file).

smp_call_function_many() is used to call functions on many cores.
It uses a bitmask to specify the target cores. Preemption must be disabled.

Basically, for each cpu in the mask take the per-CPU csd (the list) and add an
element with the func and the arg. Then send IPI and at the end, if wait is
specified, wait for the completion flag in the csd of each core.

When interrupts are disabled this function can cause deadlock!

If two cores send IPI to each other and waits until completion both are waiting
for completion and does not respond to the request.

12) I/O Interrupt Management
----------------------------

Action taken when handling an interrupt are splitted across:

 - Critical Actions: IF=0, ack the interrupt, reporgram the device, exchange
   data with the device etc..
 - Non-Critial Actions: IF=1, quick data structures management (data not shared
   with device)
 - Non-Critical Deferrable Actions: Eventually done. Anything else (e.g. copy
   data to userspace)

Interrupt service routines are the driver entry points and ends with iret.

The same IRQ can be shared by multiple devices. Multiple ISR for an IRQ.
The hardware geometry allows ISR to find out the correct routine.

In IRQ management dispatcher we use another stack if coming from userspace.
swapgs and do this shit:

We move off the initial part (the critical) to another stack
(a stack for each cpu).

mov %rsp, %rdi
mov PER_CPU_VAR(cpu_current_top_of_stack), %rsp

Then copy the interrupt frame from old stack to the new (rdi is also saved).

pushq 0x38(%rdi)
...

This is a memory-to-memory instruction. Yes, x86 is x86.

Then, begin the common code also if coming from kernel space:

Save the registers and call do_IRQ(interrupt number). The interrupt number can
be found at the top of the stack cause it is pushed by the intitial stub.

Interrupts are offs, do_IRQ performs the critical actions.

13) Deferred work
-----------------

Work from interrupts shifted in time, must be handled carefully to not
introduce starvation.

Those events can be aggregated.
This reconciliation points can be also specified.

The initial idea was to avoid to process interrupts during a critical section
that some worker locked before the arriving of interrupts.
This satisfy a soft real-time constraint.

Top half is the not critical action that is needed to finalize the interrupt.
Bottom half is the deferrable work, top half schedule it in a proper data
structure.





































































until done early kern init to communicate with harware we must use bios services.

bios: take the machine in an uniform and usable state

reset pin -> tells the cpu start exec instr

basic state: no caches, mmu disabled, real mode, only 1 core, empty ram

in real mode we have segmented memory. 
4 basic 16 bits seg regs
- cs
- ds
- ss
- es
added other fs and gs

jump uses cs implicit, push uses ss implicit.

real mode: 20 bits address space (1 mb mem)
addresses can overlaps. 0000:0000 addresses.

some addresses can be represented but not handled
(0000:0000 are more than 20 bits).
latest addr is fffff.

first fetched addr is f000:fff0 (reset vector). this is not mapped to ram but to
a rom, the bios.
in this addr we find a jump instr that sets code seg.

bios step 1: map routine to write on screen.
post phase: (depends on bios impl) checking keyboard etc..
bios try to load an os. load conf from CMOS mem to know boot order etc.
after, BIOS map to ram to give services.
bios try to identify stage 1 bootloader and load it at addr 0000:7c00. control
is given with a jump.


bootloader stage 1 (640 kb ram aval).
it must be in MBR (first sector of disk). there is also partition table here.

mbr:

jmp stage1_start
data table for partition etc...
stage1_starts:
cli
set all segs to 0 (excpet cs that is yet 0 and cannot be assigned)

enable address A20, switch to 32 bit protected mode, setup stack.
cannot load kernel that is on disk, so load stage 2.

now we have 16 mb mem.

!!! wrappend-around problem. address line 20 is forced to 0.
to activate this mem line using the 8042 keyboard controller. this operation is
slow and we must wait for it.

then we activate pages.

many control registers we activete of actuivate (bitmask) of cpu.

CR0 bit 0 is for enabling protected mode (but it happens at the following CS
update with a long jump. after this we have 32/64 bit mode). CR0 bit 31 enable paging.

in protected mode seg regs is no longer a number. it keeps an index in the
segments descriptors table.

3 types of segs:
+ code
+ data
+ system (used for priviledge levels)


Global Descriptor Table: system wide
Local Descriptor Table: not used anymore

to have linear set to 0 all entries of GDT.

The current priviledge level (CPL) (ring) is in CS (can be changed only with
ljmp/lcall).
Requested priviledge level (RPL) is in DS.

DPL is in segment descriptor and it is the priv level associated to the seg
descr.

RPL can be > CPL.

max(CPL, RPL) <= DPL : if flase generate exception

we can easily move from lower ring to higher ring (less priv)

Gate descriptors are firmware facilities to define target code that can be
reached from user space.
Thoses descriptor are referenced by the Interrupt Descriptors Table, pointed by
IDTR reg.

Trap gate descr is the way that kernel identify handlers.

we must differentiate code seg and data seg cause firmware has different
representations for CS and DS
so in the GDT in linux we have kernel CS, kernel DS, user CS, user DS

We have a GDT for each core. TSS and LDT are different for each core.

Task State Segment: keep info about a task (linked lisk)
save here cpu state for context switch but not used by linux.

If i'm changed priv level, the firmware must change stack. SS# segment registers
in TSS we have entry to store stack ptr for each priv level.

TSS on x64 is completely different. we still have stack pointers. no more spaces
for saved gpr.
added interrupt stack table, each interrupt routines can pick one of this 7
stacks. 2 bits in IDT eantry to decide, if 0 picked using ring as x86.

jumping to gate to gain priv we have yet the new stack.

Now we must init data structures for paging and enable it.

All of in MMu are physical addr. 

Page directory - table - offset.

Page table entry: pg table base addr - avail - bits.
bit present to know if the page is on disk.

TLB act as cache to not traverse PTE. 

OS when requesting mem it not give all the mem.
It is given when written, page fault.

Returning from page fault, we have in stack the addr of the instr and iret get
it, so it is re-executed.
page fault can be nested, PTE can not be on mem for example.

Linux mem layout on x86: 1GB top (0xffffffff - 0xc0000000) assigned to kernel,
3 gb to userspace.

PAE: physical addr ext. 36 bits addr. 3 level page tables. 

on x86_64 48 bits. the 48th bit is exntended until 64. jump from 0x7fff to
ffff8000. in the middle there are not canonical addr that cannot be handled.

Table 1st level PGD. x64 48 bit addr, 4 level page table.

XD bit in addr structure in x64, we can discrimiate executable page and not
only r/w.

--- 
x64 longmode must be enabled.
way more efficent to switch ring 3 - 0
no more gate for 3 - 0

Model specific register, MSR, exists only on some cpus.

rdmsr, wrmsr r/w instructions to this reg. this reg has not name.

ecx = reg code
rdmsr copy in eax msr with code ecx
wrmsr copy eax in msr with code ecx

MSR_EFER setting a bit we tell that we want long mode.
We set also paging and protected mode.
Not change until reqrite CS with lret.

MSR register can be written once. the OS write its code segment.
fast syscall path use this code segment directly.

UEFI:

- bytecode
- loads firmware from nvRAM into RAM
- startup files stored in the EFI partition
- GUID Partition Table
- secure boot (sign image of os)

with APIC one core can send int to another

Inter process interrupt. Interruct control register.
Startup bits and other to notify in broadcast starting a core.

KERNEL STARTUP YEEEE:

bootloader continuos switch real-protected mode to load kernel compressed image
in a locatation not racheable in real mode (usinf always bios facilities).

start_of_setup() stack etc... (stack at fixed loc in image like bss)

load IDT in IDTR. the linux kernel create a NULL IDT and load in idt register.
ignore all interrupts with this (all 0).

setup_gdt()

protected_mode_jump() (still do not have paging)

can address all higher level memory now

startup_32() (bootloader can give the control directly here in protected mode)

call foo
foo: pop rax

now kernel know the address in which is loaded by bootloader

now jump to actual entry point: startup_32() (same name, another fn)

asmlinkage to tell calling convetion with params on stack. __visible to avoid to
be eleminate a fn as never called.






















